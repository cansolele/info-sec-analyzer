from flask import Blueprint, request, send_file, jsonify
import xml.etree.ElementTree as ET
from dateutil import parser
import json
import datetime
import os

vulnerability_analyzer_routes = Blueprint("vulnerability_analyzer", __name__)

# Create necessary directories if they don't exist
vulnerability_analyzer_directory = os.path.join(
    os.path.dirname(__file__), "Vulnerability-analyzer"
)
uploads_directory = os.path.join(vulnerability_analyzer_directory, "uploads")
output_directory = os.path.join(vulnerability_analyzer_directory, "output")

os.makedirs(vulnerability_analyzer_directory, exist_ok=True)
os.makedirs(uploads_directory, exist_ok=True)
os.makedirs(output_directory, exist_ok=True)

cpe_mapping = {
    "cpe:/o:microsoft:windows_server_2016:-": "Windows Server 2016",
    "cpe:/o:alt:alt_8_sp": "ALT Linux 8 SP",
    "cpe:/o:microsoft:windows_10:22h2::x64": "Windows 10 22H2 (x64)",
}


@vulnerability_analyzer_routes.route("/make-vulnerability-analysis", methods=["POST"])
def make_vulnerability_analysis():
    # Check if a file is uploaded
    if "file" not in request.files:
        return "No file uploaded", 400

    file = request.files["file"]
    if file.filename == "":
        return "No file selected", 400
    # Check the file extension to handle both XML and PDF
    file_extension = os.path.splitext(file.filename)[1].lower()
    if file_extension not in [".xml"]:
        return "Invalid file format. Only XML files are allowed.", 400

    # Save the uploaded file
    current_datetime = datetime.datetime.now().strftime("%d%m%y_%H%M%S")
    filename = f"Vulnerabilities_{current_datetime}"
    file_path = os.path.join(uploads_directory, filename + file_extension)
    file.save(file_path)

    vulenrabilities_json = os.path.join(
        output_directory, f"Vulnerabilities_{current_datetime}.json"
    )
    tree = ET.parse(file_path)
    root = tree.getroot()

    vulnerability_data = {}

    for target_report in root.findall(".//job_report/target_report"):
        target_id = target_report.find("target").text
        target_address = root.find(
            f".//targets/target[@inner_id='{target_id}']/address"
        ).text
        target_vulnerabilities = target_report.findall(".//vulnerability")

        critical_count = 0
        high_count = 0
        medium_count = 0
        low_count = 0
        unavailable_count = 0

        # Extract CPE information from result element
        cpe = target_report.find("result").get("cpe")
        if cpe in cpe_mapping:
            cpe = cpe_mapping[cpe]

        for vulnerability in target_vulnerabilities:
            inner_id = vulnerability.get("inner_id")
            definition = root.find(f".//definition[@inner_id='{inner_id}']")
            severity = definition.get("severity")

            if severity == "Critical":
                critical_count += 1
            elif severity == "High":
                high_count += 1
            elif severity == "Medium":
                medium_count += 1
            elif severity == "Low":
                low_count += 1
            elif severity == "NotAvailable":
                unavailable_count += 1

        vulnerability_data[target_address] = {
            "Critical": critical_count,
            "High": high_count,
            "Medium": medium_count,
            "Low": low_count,
            "Unavailable": unavailable_count,
            "Total": critical_count
            + high_count
            + medium_count
            + low_count
            + unavailable_count,
            "CPE": cpe,  # Include CPE information
        }

    # Extract the desired information from the XML
    formatted_creation_time = parser.parse(root.attrib.get("creation_time")).strftime(
        "%d.%m.%Y %H:%M:%S"
    )

    earliest_start_time = None
    latest_stop_time = None

    for target_report in root.findall(".//body/job_report/target_report"):
        for result in target_report.findall(".//result"):
            start_time_str = result.get("start")
            stop_time_str = result.get("stop")

            start_time = parser.parse(start_time_str)
            stop_time = parser.parse(stop_time_str)

            if earliest_start_time is None or start_time < earliest_start_time:
                earliest_start_time = start_time

            if latest_stop_time is None or stop_time > latest_stop_time:
                latest_stop_time = stop_time

    target_hosts = root.find(".//metadata/options/targets").text

    total_vulnerabilities = 0

    for target_data in vulnerability_data.values():
        total_vulnerabilities += target_data["Total"]

    percent_data = {
        "Critical": 0.00,
        "High": 0.00,
        "Medium": 0.00,
        "Low": 0.00,
        "Unavailable": 0.00,
    }

    for target_data in vulnerability_data.values():
        if total_vulnerabilities > 0:
            percent_data["Critical"] += round(
                (target_data["Critical"] / total_vulnerabilities) * 100, 2
            )
            percent_data["High"] += round(
                (target_data["High"] / total_vulnerabilities) * 100, 2
            )
            percent_data["Medium"] += round(
                (target_data["Medium"] / total_vulnerabilities) * 100, 2
            )
            percent_data["Low"] += round(
                (target_data["Low"] / total_vulnerabilities) * 100, 2
            )
            percent_data["Unavailable"] += round(
                (target_data["Unavailable"] / total_vulnerabilities) * 100, 2
            )

    # Convert the percentages to strings with fixed decimal places
    percent_data = {k: "{:.2f}".format(v) for k, v in percent_data.items()}

    result = {
        "creation_time": formatted_creation_time,
        "start_time": earliest_start_time.strftime("%d.%m.%Y %H:%M:S"),
        "end_time": latest_stop_time.strftime("%d.%m.%Y %H:%M:S"),
        "target_hosts": target_hosts.replace(";", "; "),
        "percent": percent_data,  # Include percentage information
        "vulnerabilities": vulnerability_data,
    }

    with open(vulenrabilities_json, "w") as vulnerabilities_file:
        json.dump(result, vulnerabilities_file, indent=4)

    return jsonify(result)
