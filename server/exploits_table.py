from flask import Blueprint, request, send_file, jsonify, session
from flask_socketio import emit
import os
import json
import requests
import subprocess
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from datetime import datetime


# Create a Flask Blueprint for the exploits_table routes
exploits_table_routes = Blueprint("exploits_table", __name__)

# Create necessary directories if they don't exist
exploits_table_directory = os.path.join(os.path.dirname(__file__), "Exploits-table")
uploads_directory = os.path.join(exploits_table_directory, "uploads")
info_directory = os.path.join(exploits_table_directory, "info")
output_directory = os.path.join(exploits_table_directory, "output")

os.makedirs(exploits_table_directory, exist_ok=True)
os.makedirs(uploads_directory, exist_ok=True)
os.makedirs(info_directory, exist_ok=True)
os.makedirs(output_directory, exist_ok=True)


@exploits_table_routes.route("/make-exploits-table", methods=["POST"])
def make_table():
    # Check if a file is uploaded
    if "file" not in request.files:
        return "No file uploaded", 400

    file = request.files["file"]
    if file.filename == "":
        return "No file selected", 400

    # Check the file extension to handle both XML and PDF
    file_extension = os.path.splitext(file.filename)[1].lower()
    if file_extension not in [".xml", ".pdf", ".txt"]:
        return "Invalid file format. Only XML and PDF files are allowed.", 400

    # Download known exploited vulnerabilities (kev) JSON data from CISA
    kev_json_path = os.path.join(info_directory, "kev.json")
    if not os.path.exists(kev_json_path):
        kev_url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
        response = requests.get(kev_url)
        if response.status_code == 200:
            with open(kev_json_path, "wb") as kev_file:
                kev_file.write(response.content)

    # Save the uploaded file
    current_datetime = datetime.now().strftime("%d%m%y_%H%M%S")
    filename = f"ExploitsTable_{current_datetime}"
    file_path = os.path.join(uploads_directory, filename + file_extension)
    file.save(file_path)

    # Paths for output files
    output_file_cve = os.path.join(
        output_directory,
        f"CveList_{current_datetime}.txt",
    )
    output_file_exploits_temp = os.path.join(
        output_directory,
        f"ExploitsTableTemp_{current_datetime}.json",
    )

    vulnerability_scanner = request.form.get("selectedScanner")
    if vulnerability_scanner == "REDCheck":
        # Modify the extract_cve_command based on the file extension
        if file_extension == ".xml":
            extract_cve_command = f"xpath -e '//vulnerability/@cve|//reference/@ref_id' {file_path} | grep 'CVE' | sed -r 's/^.*CVE-([0-9]{{4}})-([0-9]{{4,7}}).*$/\\1-\\2/g' | sort | uniq > '{output_file_cve}'"
        else:  # For PDF files
            extract_cve_command = f"pdfgrep -o -P 'CVE-[0-9]{{4}}-[0-9]{{4,7}}' '{file_path}' | sed -r 's/^CVE-//g' | sort | uniq > '{output_file_cve}'"
    elif vulnerability_scanner == "NmapVulners":
        extract_cve_command = f"xpath -e '//table/elem[@key=\"id\"]/text()' {file_path} | grep 'CVE-' | sed -r 's/^CVE-//g' | sort | uniq > '{output_file_cve}'"
    elif vulnerability_scanner == "CveList":
        extract_cve_command = f"cat '{file_path}' | grep 'CVE-' | sed -r 's/^CVE-//g' | sort | uniq > '{output_file_cve}'"

    subprocess.run(extract_cve_command, shell=True)

    # Read the extracted CVEs from the text file
    cve_list = []
    with open(output_file_cve, "r") as cve_file:
        cve_list = cve_file.read().splitlines()

    cve_cntr = 0
    cve_total = len(cve_list)
    # Extract exploit data for each CVE and save it to a JSON file
    exploits_data = []
    for cve in cve_list:
        search_exploit_command = (
            f"searchsploit --cve {cve} -j > '{output_file_exploits_temp}'"
        )
        subprocess.run(search_exploit_command, shell=True)
        with open(output_file_exploits_temp) as exploits_file:
            expl_j_data = json.load(exploits_file)
            cve_data = {cve: expl_j_data["RESULTS_EXPLOIT"]}
            exploits_data.append(cve_data)
        cve_cntr += 1

        progress = {
            "cve_cntr": cve_cntr,
            "cve_total": cve_total,
            "key": request.form.get("key"),
        }

        sid = request.form.get("sid")
        emit("progress", progress, room=sid, namespace="/")

    # Create an Excel table with the extracted data
    output_file_excel = os.path.join(
        output_directory,
        f"Exploits_{current_datetime}.xlsx",
    )
    create_excel_table(exploits_data, output_file_excel)

    update_report_history(output_file_excel, current_datetime, vulnerability_scanner)

    os.remove(output_file_cve)
    os.remove(output_file_exploits_temp)

    # Provide a download link for the generated Excel file
    download_link = request.host_url + f"download/{current_datetime}"
    return {"downloadLink": download_link, "timestamp": current_datetime}


# Function to update the ReportHistory.json file
def update_report_history(output_file, current_datetime, vulnerability_scanner):
    report_history_file = os.path.join(info_directory, "ReportHistory.json")

    # Load existing report history if it exists, or create an empty list
    if os.path.exists(report_history_file):
        with open(report_history_file, "r") as json_file:
            report_history = json.load(json_file)
    else:
        report_history = []

    # Add the new report file to the history
    datetime_obj = datetime.strptime(current_datetime, "%d%m%y_%H%M%S")
    formatted_time = datetime_obj.strftime("%d.%m.%Y %H:%M:%S")
    report_info = {
        "filename": os.path.basename(output_file),
        "timestamp": current_datetime,
        "time": formatted_time,
        "vulnerabilityScanner": vulnerability_scanner,
    }
    report_history.append(report_info)

    # Save the updated report history
    with open(report_history_file, "w") as json_file:
        json.dump(report_history, json_file)

    emit(
        "reportHistoryUpdated",
        {"message": "Report history updated"},
        namespace="/",
        broadcast=True,
    )


# Function to check CVE information in the downloaded kev JSON file
def check_cve_kev(cve):
    with open(os.path.join(info_directory, "kev.json")) as kev_file:
        kev_data = json.load(kev_file)
        vulnerabilities = kev_data.get("vulnerabilities", [])
        for vulnerability in vulnerabilities:
            if ("CVE-" + cve) == vulnerability.get("cveID"):
                return vulnerability
        return None


# Function to create an Excel table from the extracted data
def create_excel_table(exploits_data, output_file):
    table_language = request.form.get("tableLanguage")
    # Create a new Excel workbook and set up the worksheet
    wb = Workbook()
    ws = wb.active
    if table_language == "ENG":
        ws.title = "Exploits"
    else:
        ws.title = "Эксплоиты"

    # Define the table headers and chapters
    chapters_eng = [
        "ExploitDB",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "Known Exploited Vulnerabilities",
    ]
    headers_eng = [
        "№",
        "CVE ID",
        "Date published",
        "Date updated",
        "Title",
        "Type",
        "Platform",
        "URL",
        "Product",
        "Description",
        "Required action",
        "Notes",
    ]
    chapters_rus = [
        "ExploitDB",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "Широкоизвестные эксплуатируемые уязвимости (KEV)",
    ]
    headers_rus = [
        "№",
        "Код CVE",
        "Дата публикации",
        "Дата обновления",
        "Заголовок",
        "Тип",
        "Платформа",
        "Ссылка",
        "Продукт",
        "Описание",
        "Требуемое действие",
        "Примечание",
    ]

    # Write chapters and headers to the worksheet
    if table_language == "ENG":
        ws.append(chapters_eng)
        ws.append(headers_eng)
    else:
        ws.append(chapters_rus)
        ws.append(headers_rus)
    ws.freeze_panes = "A3"

    # Apply formatting to the headers
    bold_font_header = Font(name="Bahnschrift SemiLight SemiConde", bold=True, size=13)
    olive_fill = PatternFill(
        start_color="ff4aa71b", end_color="ff4aa71b", fill_type="solid"
    )
    for row in ws.iter_rows(
        min_row=1, max_row=2, min_col=1, max_col=8
    ):  # Adjusted max_col
        for cell in row:
            cell.fill = olive_fill

    light_blue_fill = PatternFill(
        start_color="FFADD8E6", end_color="FFADD8E6", fill_type="solid"
    )
    for row in ws.iter_rows(
        min_row=1, max_row=2, min_col=9, max_col=12
    ):  # Adjusted min_col and max_col
        for cell in row:
            cell.fill = light_blue_fill

    ws.merge_cells(
        start_row=1, start_column=1, end_row=1, end_column=8
    )  # Adjusted end_column
    ws.merge_cells(
        start_row=1, start_column=9, end_row=1, end_column=12
    )  # Adjusted start_column and end_column

    # Write exploit data to the worksheet
    row_number = 0
    for exploit in exploits_data:
        for cve, results in exploit.items():
            if results:
                for result in results:
                    kev_vulnerability = check_cve_kev(cve)
                    if "Codes" in result and ("CVE-" + cve) in result["Codes"].split(
                        ";"
                    ):
                        row_number += 1
                        row = [
                            row_number,
                            "CVE-" + cve,
                            result.get("Date_Published", ""),
                            result.get("Date_Updated", ""),
                            result.get("Title", ""),
                            result.get("Type", ""),
                            result.get("Platform", ""),
                            f"https://www.exploit-db.com/exploits/{result.get('EDB-ID', '')}",
                        ]
                        if kev_vulnerability:
                            row.extend(
                                [
                                    kev_vulnerability.get("product", ""),
                                    kev_vulnerability.get("shortDescription", ""),
                                    kev_vulnerability.get("requiredAction", ""),
                                    kev_vulnerability.get("notes", ""),
                                ]
                            )
                        else:
                            row.extend(["", "", "", ""])
                        ws.append(row)

    # Add hyperlinks to the "URL" column
    for row in ws.iter_rows(min_row=3, min_col=8, max_col=8):  # Adjusted max_col
        for cell in row:
            cell.hyperlink = cell.value

    # Adjust column widths and apply formatting
    max_column_width = 70
    for column in ws.columns:
        max_length = 10
        column_letter = column[1].column_letter
        for cell in column:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except:
                pass
        adjusted_width = min(max_length + 2, max_column_width)
        ws.column_dimensions[column_letter].width = adjusted_width * 1.15

        for cell in column:
            cell.alignment = Alignment(horizontal="center", vertical="center")
            if cell.column in [5, 10, 12]:  # Adjusted column numbers
                cell.alignment = Alignment(
                    horizontal="center", vertical="center", wrap_text=True
                )
            if cell.row == 1 or cell.row == 2:
                cell.font = bold_font_header
            else:
                cell.font = Font(name="Bahnschrift SemiLight SemiConde", size=13)

    all_borders = Border(
        left=Side(border_style="thin"),
        right=Side(border_style="thin"),
        top=Side(border_style="thin"),
        bottom=Side(border_style="thin"),
    )

    for row in ws.iter_rows():
        for cell in row:
            cell.border = all_borders

    for row in ws.iter_rows(min_row=3, min_col=6, max_col=6):
        for cell in row:
            if cell.value == "local":
                cell.fill = PatternFill(
                    start_color="FF7400", end_color="FF7400", fill_type="solid"
                )
            elif cell.value == "dos":
                cell.fill = PatternFill(
                    start_color="FFE800", end_color="FFE800", fill_type="solid"
                )
            elif cell.value in ["remote", "webapps"]:
                cell.fill = PatternFill(
                    start_color="FF0404", end_color="FF0404", fill_type="solid"
                )

    for row in ws.iter_rows(min_row=3, min_col=6, max_col=6):
        for cell in row:
            product_cell = ws.cell(row=cell.row, column=9)
            if product_cell.value:
                cell.fill = PatternFill(
                    start_color="A52A2A", end_color="A52A2A", fill_type="solid"
                )

    # Save the workbook as an Excel file
    wb.save(output_file)


@exploits_table_routes.route("/download/<timestamp>", methods=["GET"])
def download_file(timestamp):
    output_file = os.path.join(output_directory, f"Exploits_{timestamp}.xlsx")
    if not os.path.exists(output_file):
        return "File not found", 404

    return send_file(output_file, as_attachment=True)


@exploits_table_routes.route("/file-history", methods=["GET"])
def file_history():
    report_history_file = os.path.join(info_directory, "ReportHistory.json")

    if not os.path.exists(report_history_file):
        return jsonify([])

    with open(report_history_file, "r") as json_file:
        report_history = json.load(json_file)

    return jsonify(report_history)
